<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>{% if page.title %}{{ page.title }} · {{ site.title }}{% else %}{{ site.title }} · Product Design Leader{% endif %}</title>
<meta name="description" content="{{ page.description | default: site.description }}" />
<meta name="theme-color" content="#050712" />
<script>
  (function () {
    const backgroundData = {{ site.data.background | jsonify | replace: '</', '<\/' }};

    const FALLBACK_BACKGROUND_HEX = (() => {
      if (backgroundData && typeof backgroundData.color === 'string' && backgroundData.color.trim()) {
        return backgroundData.color;
      }
      return '#050712';
    })();

    const hexToRgb = (hex) => {
      if (typeof hex !== 'string') {
        return null;
      }

      const trimmed = hex.trim().replace('#', '');
      if (![3, 6].includes(trimmed.length)) {
        return null;
      }

      const normalized = trimmed.length === 3 ? trimmed.split('').map((char) => char + char).join('') : trimmed;
      const bigint = Number.parseInt(normalized, 16);

      if (Number.isNaN(bigint)) {
        return null;
      }

      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    };

    const clamp01 = (value) => {
      const numeric = Number(value);
      if (Number.isNaN(numeric)) {
        return 0;
      }
      return Math.min(Math.max(numeric, 0), 1);
    };

    const mixRgb = (start, end, factor = 0.5) => {
      if (!start || !end) {
        return start || end || null;
      }

      const mixFactor = clamp01(factor);
      return {
        r: Math.round(start.r + (end.r - start.r) * mixFactor),
        g: Math.round(start.g + (end.g - start.g) * mixFactor),
        b: Math.round(start.b + (end.b - start.b) * mixFactor)
      };
    };

    const WHITE = { r: 255, g: 255, b: 255 };
    const BLACK = { r: 0, g: 0, b: 0 };

    const srgbChannelToLinear = (value) => {
      const channel = value / 255;
      if (channel <= 0.04045) {
        return channel / 12.92;
      }
      return Math.pow((channel + 0.055) / 1.055, 2.4);
    };

    const getRelativeLuminance = (color) => {
      if (!color) {
        return 0;
      }
      return 0.2126 * srgbChannelToLinear(color.r) + 0.7152 * srgbChannelToLinear(color.g) + 0.0722 * srgbChannelToLinear(color.b);
    };

    const mixWith = (color, target, factor) => mixRgb(color, target, factor);
    const lighten = (color, factor = 0.5) => mixWith(color, WHITE, factor);
    const darken = (color, factor = 0.5) => mixWith(color, BLACK, factor);

    const getReadableTextOn = (background) => {
      if (!background) {
        return WHITE;
      }

      const luminance = getRelativeLuminance(background);

      if (luminance >= 0.75) {
        return darken(background, 0.85);
      }

      if (luminance <= 0.25) {
        return lighten(background, 0.85);
      }

      return luminance > 0.5 ? darken(background, 0.7) : lighten(background, 0.7);
    };

    const rgbaToString = (color, alpha = 1) => {
      if (!color) {
        return '';
      }
      const { r, g, b } = color;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    const rgbValuesToString = (color) => {
      if (!color) {
        return '0, 0, 0';
      }
      const { r, g, b } = color;
      return `${r}, ${g}, ${b}`;
    };

    const componentToHex = (value) => {
      const clamped = Math.max(0, Math.min(255, Math.round(value)));
      return clamped.toString(16).padStart(2, '0');
    };

    const rgbToHex = (color) => {
      if (!color) {
        return '';
      }
      return `#${componentToHex(color.r)}${componentToHex(color.g)}${componentToHex(color.b)}`;
    };

    const normalizeHex = (hex) => {
      const color = hexToRgb(hex);
      return color ? rgbToHex(color) : null;
    };

    const buildBackgroundConfig = (entry, fallbackLabel) => {
      if (!entry || typeof entry !== 'object') {
        return null;
      }

      const color = typeof entry.color === 'string' && entry.color.trim() ? entry.color : null;
      const label =
        (typeof entry.label === 'string' && entry.label.trim()) ||
        (typeof fallbackLabel === 'string' && fallbackLabel.trim()) ||
        '';

      if (!color) {
        return null;
      }

      return { color, label };
    };

    const parseTimeToMinutes = (value) => {
      const TOTAL_MINUTES = 24 * 60;

      if (typeof value === 'number' && Number.isFinite(value)) {
        const clampedHours = Math.max(0, Math.min(24, value));
        return Math.round(clampedHours * 60);
      }

      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) {
          return null;
        }

        const match = trimmed.match(/^(\d{1,2})(?::(\d{1,2}))?$/);
        if (!match) {
          return null;
        }

        const hours = Number.parseInt(match[1], 10);
        const minutes = match[2] ? Number.parseInt(match[2], 10) : 0;

        if (Number.isNaN(hours) || Number.isNaN(minutes)) {
          return null;
        }

        if (hours === 24 && minutes === 0) {
          return 0;
        }

        if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
          return null;
        }

        return hours * 60 + minutes;
      }

      return null;
    };

    const mapTimeAnchors = () => {
      const anchors = new Map();
      const TOTAL_MINUTES = 24 * 60;

      const registerAnchor = (minutes, entry) => {
        if (!Number.isFinite(minutes)) {
          return;
        }

        const normalizedMinutes = ((minutes % TOTAL_MINUTES) + TOTAL_MINUTES) % TOTAL_MINUTES;
        const config = buildBackgroundConfig(entry, backgroundData?.label);
        if (!config) {
          return;
        }

        const colorHex = normalizeHex(config.color);

        if (!colorHex) {
          return;
        }

        anchors.set(normalizedMinutes, {
          minutes: normalizedMinutes,
          color: colorHex,
          label: config.label
        });
      };

      if (backgroundData && Array.isArray(backgroundData.time_points)) {
        backgroundData.time_points.forEach((point) => {
          if (!point || typeof point !== 'object') {
            return;
          }

          const minutes =
            parseTimeToMinutes(point.time) ??
            parseTimeToMinutes(typeof point.hour === 'number' ? point.hour : null);

          registerAnchor(minutes, point);
        });
      } else if (backgroundData && Array.isArray(backgroundData.time_ranges)) {
        backgroundData.time_ranges.forEach((range) => {
          if (!range || typeof range !== 'object') {
            return;
          }

          const startMinutes = parseTimeToMinutes(range.start_hour);
          registerAnchor(startMinutes, range);
        });
      }

      return Array.from(anchors.values()).sort((a, b) => a.minutes - b.minutes);
    };

      const getDefaultBackground = () => {
        const fallback = buildBackgroundConfig(backgroundData?.default || backgroundData, backgroundData?.label);
        if (fallback && fallback.color) {
          return fallback;
        }

        return { color: FALLBACK_BACKGROUND_HEX, label: backgroundData?.label || '' };
      };

    const resolveInterpolatedBackground = () => {
      const anchors = mapTimeAnchors();
      if (!anchors.length) {
        return null;
      }

        if (anchors.length === 1) {
          const single = anchors[0];
          return {
            color: single.color,
            label: single.label
          };
        }

      const TOTAL_MINUTES = 24 * 60;
      const now = new Date();
      const currentMinutes = now.getHours() * 60 + now.getMinutes() + now.getSeconds() / 60;

      let previous = anchors[anchors.length - 1];
      let next = anchors[0];

      for (const anchor of anchors) {
        if (currentMinutes >= anchor.minutes) {
          previous = anchor;
        } else {
          next = anchor;
          break;
        }
      }

        if (previous.minutes === next.minutes) {
          return {
            color: previous.color,
            label: previous.label
          };
        }

      let startMinutes = previous.minutes;
      let endMinutes = next.minutes;

      if (endMinutes <= startMinutes) {
        endMinutes += TOTAL_MINUTES;
      }

      let elapsed = currentMinutes - startMinutes;
      if (elapsed < 0) {
        elapsed += TOTAL_MINUTES;
      }

        const duration = endMinutes - startMinutes;
        const mixFactor = duration === 0 ? 0 : clamp01(elapsed / duration);

        const startColor = hexToRgb(previous.color) || fallbackColor;
        const endColor = hexToRgb(next.color) || startColor;

        const baseColor = mixRgb(startColor, endColor, mixFactor) || startColor;

        const label = mixFactor < 0.5 ? previous.label : next.label || previous.label;

        return {
          color: rgbToHex(baseColor),
          label
        };
      };

    const getActiveBackground = () => {
      const interpolated = resolveInterpolatedBackground();
      if (interpolated) {
        return interpolated;
      }

      return getDefaultBackground();
    };

      const applyDynamicPalette = (baseColor) => {
        if (!baseColor) {
          return;
        }

        const midpoint = baseColor;
        const luminance = getRelativeLuminance(midpoint);
        const isDarkBackground = luminance < 0.48;

        const glassBackgroundTint = isDarkBackground ? darken(midpoint, 0.72) : lighten(midpoint, 0.82);
        const glassBorderTint = isDarkBackground ? darken(midpoint, 0.62) : lighten(midpoint, 0.7);
        const glassTextTint = isDarkBackground ? lighten(midpoint, 0.96) : darken(midpoint, 0.92);
        const glassTextMutedTint = isDarkBackground ? lighten(midpoint, 0.88) : darken(midpoint, 0.8);
        const controlSurfaceTint = isDarkBackground ? darken(midpoint, 0.64) : lighten(midpoint, 0.78);
        const controlSurfaceHoverTint = isDarkBackground ? darken(midpoint, 0.58) : lighten(midpoint, 0.86);
        const controlTextTint = isDarkBackground ? lighten(midpoint, 0.98) : darken(midpoint, 0.94);
        const textPrimaryTint = isDarkBackground ? lighten(midpoint, 0.98) : darken(midpoint, 0.92);
        const textMutedTint = isDarkBackground ? lighten(midpoint, 0.9) : darken(midpoint, 0.82);

        const cardBackgroundTint = isDarkBackground ? lighten(midpoint, 0.92) : darken(midpoint, 0.68);
        const cardBorderTint = isDarkBackground ? lighten(midpoint, 0.82) : darken(midpoint, 0.58);
        const cardShadowTint = darken(midpoint, isDarkBackground ? 0.88 : 0.54);
        const cardTextTint = getReadableTextOn(cardBackgroundTint);
        const cardTextMutedTint = mixRgb(cardTextTint, cardBackgroundTint, 0.45);

        const glassBackgroundAlpha = isDarkBackground ? 0.78 : 0.62;
        const controlSurfaceAlpha = isDarkBackground ? 0.42 : 0.26;
        const controlSurfaceHoverAlpha = isDarkBackground ? 0.48 : 0.34;

        const navPanelTint = isDarkBackground ? darken(midpoint, 0.68) : lighten(midpoint, 0.86);
        const navPanelAlpha = isDarkBackground ? 0.88 : 0.72;
        const navBorderTint = isDarkBackground ? darken(midpoint, 0.58) : lighten(midpoint, 0.7);
        const navDividerTint = isDarkBackground ? lighten(midpoint, 0.78) : darken(midpoint, 0.62);
        const navOverlayTint = isDarkBackground ? darken(midpoint, 0.94) : darken(midpoint, 0.7);
        const navOverlayAlpha = isDarkBackground ? 0.68 : 0.5;
        const shadowTint = darken(midpoint, isDarkBackground ? 0.9 : 0.75);

        const palette = {
          '--dynamic-text-on-background': `rgb(${textPrimaryTint.r}, ${textPrimaryTint.g}, ${textPrimaryTint.b})`,
          '--dynamic-text-muted': rgbaToString(textMutedTint, isDarkBackground ? 0.82 : 0.78),
          '--dynamic-glass-background': rgbaToString(glassBackgroundTint, glassBackgroundAlpha),
          '--dynamic-glass-border': rgbaToString(glassBorderTint, isDarkBackground ? 0.5 : 0.42),
          '--dynamic-glass-text': `rgb(${glassTextTint.r}, ${glassTextTint.g}, ${glassTextTint.b})`,
          '--dynamic-glass-text-muted': rgbaToString(glassTextMutedTint, isDarkBackground ? 0.8 : 0.76),
          '--dynamic-card-background': `rgb(${cardBackgroundTint.r}, ${cardBackgroundTint.g}, ${cardBackgroundTint.b})`,
          '--dynamic-card-border': rgbaToString(cardBorderTint, isDarkBackground ? 0.3 : 0.36),
          '--dynamic-card-text': `rgb(${cardTextTint.r}, ${cardTextTint.g}, ${cardTextTint.b})`,
          '--dynamic-card-text-muted': rgbaToString(cardTextMutedTint, 0.82),
          '--dynamic-card-shadow-rgb': rgbValuesToString(cardShadowTint),
          '--dynamic-control-surface': rgbaToString(controlSurfaceTint, controlSurfaceAlpha),
          '--dynamic-control-surface-hover': rgbaToString(controlSurfaceHoverTint, controlSurfaceHoverAlpha),
          '--dynamic-control-text': `rgb(${controlTextTint.r}, ${controlTextTint.g}, ${controlTextTint.b})`,
          '--dynamic-nav-panel-background': rgbaToString(navPanelTint, navPanelAlpha),
          '--dynamic-nav-panel-border': rgbaToString(navBorderTint, isDarkBackground ? 0.55 : 0.4),
          '--dynamic-nav-divider-rgb': rgbValuesToString(navDividerTint),
          '--dynamic-nav-overlay': rgbaToString(navOverlayTint, navOverlayAlpha),
          '--dynamic-shadow-rgb': rgbValuesToString(shadowTint)
        };

        const rootElement = document.documentElement;
        Object.entries(palette).forEach(([variable, value]) => {
          if (value) {
            rootElement.style.setProperty(variable, value);
          }
        });

      const createAccentPalette = (color, isDark) => {
        const { h, s, l } = (() => {
          const rNorm = color.r / 255;
          const gNorm = color.g / 255;
          const bNorm = color.b / 255;
          const max = Math.max(rNorm, gNorm, bNorm);
          const min = Math.min(rNorm, gNorm, bNorm);
          const delta = max - min;
          let h = 0;
          let sAcc = 0;
          const lAcc = (max + min) / 2;

          if (delta !== 0) {
            sAcc = lAcc > 0.5 ? delta / (2 - max - min) : delta / (max + min);

            switch (max) {
              case rNorm:
                h = (gNorm - bNorm) / delta + (gNorm < bNorm ? 6 : 0);
                break;
              case gNorm:
                h = (bNorm - rNorm) / delta + 2;
                break;
              default:
                h = (rNorm - gNorm) / delta + 4;
                break;
            }

            h /= 6;
          }

          return { h, s: sAcc, l: lAcc };
        })();

        const hueToRgb = (p, q, t) => {
          let tempT = t;
          if (tempT < 0) tempT += 1;
          if (tempT > 1) tempT -= 1;
          if (tempT < 1 / 6) return p + (q - p) * 6 * tempT;
          if (tempT < 1 / 2) return q;
          if (tempT < 2 / 3) return p + (q - p) * (2 / 3 - tempT) * 6;
          return p;
        };

        const build = (sat, light) => {
          if (sat === 0) {
            const gray = Math.round(light * 255);
            return { r: gray, g: gray, b: gray };
          }

          const q = light < 0.5 ? light * (1 + sat) : light + sat - light * sat;
          const p = 2 * light - q;

          return {
            r: Math.round(hueToRgb(p, q, h + 1 / 3) * 255),
            g: Math.round(hueToRgb(p, q, h) * 255),
            b: Math.round(hueToRgb(p, q, h - 1 / 3) * 255)
          };
        };

        const boostedSaturation = clamp01(s * 1.35 + 0.08);
        const baseLightness = isDark ? Math.min(0.72, Math.max(l + 0.18, 0.55)) : Math.max(0.3, Math.min(l - 0.2, 0.44));

        const base = build(boostedSaturation, baseLightness);
        const hover = build(clamp01(boostedSaturation * (isDark ? 1.05 : 0.95)), isDark ? Math.min(0.82, baseLightness + 0.08) : Math.max(0.22, baseLightness - 0.08));
        const strong = build(clamp01(boostedSaturation * (isDark ? 1.02 : 1.1)), isDark ? Math.min(0.65, baseLightness + 0.02) : Math.max(0.18, baseLightness - 0.12));
        const muted = build(clamp01(boostedSaturation * 0.6), isDark ? Math.min(0.9, baseLightness + 0.18) : Math.max(0.16, baseLightness - 0.18));

        const contrast = getRelativeLuminance(base) > 0.55 ? '#0f172a' : '#f8fafc';

        return { base, hover, strong, muted, contrast };
      };

      const { base, hover, strong, muted, contrast } = createAccentPalette(midpoint, isDarkBackground);
      const accentVariables = {
        '--dynamic-accent': `rgb(${base.r}, ${base.g}, ${base.b})`,
        '--dynamic-accent-rgb': rgbValuesToString(base),
        '--dynamic-accent-hover': `rgb(${hover.r}, ${hover.g}, ${hover.b})`,
        '--dynamic-accent-hover-rgb': rgbValuesToString(hover),
        '--dynamic-accent-strong': `rgb(${strong.r}, ${strong.g}, ${strong.b})`,
        '--dynamic-accent-strong-rgb': rgbValuesToString(strong),
        '--dynamic-accent-muted': `rgb(${muted.r}, ${muted.g}, ${muted.b})`,
        '--dynamic-accent-muted-rgb': rgbValuesToString(muted),
        '--dynamic-accent-contrast': contrast
      };

      Object.entries(accentVariables).forEach(([variable, value]) => {
        rootElement.style.setProperty(variable, value);
      });
    };

    const fallbackHexNormalized = normalizeHex(FALLBACK_BACKGROUND_HEX) || '#050712';
    const fallbackColor = hexToRgb(fallbackHexNormalized) || { r: 5, g: 7, b: 18 };

      const applyImmediateBackground = () => {
        const activeBackground = getActiveBackground();
        const colorHex = normalizeHex(activeBackground?.color) || fallbackHexNormalized;

        const baseColor = hexToRgb(colorHex) || fallbackColor;
        const baseHex = rgbToHex(baseColor) || colorHex || fallbackHexNormalized;

      const rootElement = document.documentElement;
      if (!rootElement) {
        return;
      }

        rootElement.style.setProperty('--sky-background-color', baseHex);
        rootElement.style.setProperty('--sky-background-rgb', rgbValuesToString(baseColor));
      rootElement.style.backgroundColor = baseHex;
      rootElement.style.backgroundImage = 'none';

      if (activeBackground?.label) {
        rootElement.setAttribute('data-sky-label', activeBackground.label);
      } else {
        rootElement.removeAttribute('data-sky-label');
      }

        applyDynamicPalette(baseColor);

        const themeColorMeta = document.querySelector('meta[name="theme-color"]');
        if (themeColorMeta) {
          themeColorMeta.setAttribute('content', baseHex);
        }
    };

    applyImmediateBackground();

    window.__liamSky = {
      backgroundData,
      FALLBACK_BACKGROUND_HEX,
      utils: {
        hexToRgb,
        rgbToHex,
        normalizeHex,
        mixRgb,
        clamp01,
        lighten,
        darken,
        getRelativeLuminance,
        getReadableTextOn,
        rgbaToString,
        rgbValuesToString
      },
      helpers: {
        buildBackgroundConfig,
        parseTimeToMinutes,
        mapTimeAnchors,
        getDefaultBackground,
        resolveInterpolatedBackground,
        getActiveBackground,
        applyDynamicPalette
      },
      fallback: {
        hex: fallbackHexNormalized,
        color: fallbackColor
      }
    };
  })();
</script>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
<link rel="stylesheet" href="{{ '/assets/css/tailwind.css' | relative_url }}" />
<link rel="stylesheet" href="{{ '/assets/css/style.css' | relative_url }}" />
{% seo %}
