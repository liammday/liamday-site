<!DOCTYPE html>
<html lang="en">
  <head>
    {% include head.html %}
  </head>
  <body class="flex min-h-screen flex-col font-sans text-slate-900">
    <a
      class="sr-only focus:not-sr-only focus:absolute focus:left-6 focus:top-6 focus:rounded-full focus:bg-brand focus:px-4 focus:py-2 focus:text-white focus:shadow-lg"
      href="#main"
      >Skip to content</a
    >
    <header class="site-header" data-site-header>
      <div class="site-header__bar">
        <a class="site-header__brand" href="{{ "/" | relative_url }}">{{ site.title }}</a>
        <nav class="site-nav" aria-label="Primary" data-nav>
          <button
            class="site-nav__toggle"
            aria-expanded="false"
            aria-controls="primary-navigation"
            type="button"
            data-nav-toggle
          >
            <span class="sr-only">Toggle navigation</span>
            <span aria-hidden="true" class="site-nav__toggle-bar"></span>
            <span aria-hidden="true" class="site-nav__toggle-bar"></span>
            <span aria-hidden="true" class="site-nav__toggle-bar site-nav__toggle-bar--short"></span>
          </button>
          <div class="site-nav__overlay" data-nav-overlay></div>
          <ul id="primary-navigation" class="site-nav__list" data-nav-list>
            {% for link in site.nav_links %}
            <li class="site-nav__item">
              <a class="site-nav__link" href="{{ link.url | relative_url }}">{{ link.title }}</a>
            </li>
            {% endfor %}
          </ul>
        </nav>
      </div>
    </header>

    <main id="main" class="flex-1 pt-28 md:pt-32">
      {{ content }}
    </main>

    <footer class="border-t border-slate-200 py-12">
      <div class="mx-auto flex w-full max-w-6xl flex-col gap-8 px-6 text-sm text-slate-600 sm:text-base lg:flex-row lg:items-start lg:justify-between">
        <div class="space-y-3">
          <p class="text-lg font-semibold text-slate-900">Let’s collaborate.</p>
          <a class="inline-flex items-center gap-2 text-brand-dark hover:text-brand" href="mailto:{{ site.social.email }}">
            <span>{{ site.social.email }}</span>
          </a>
        </div>
        <div class="flex flex-1 flex-col gap-4 sm:flex-row sm:items-end sm:justify-end">
          <ul class="flex flex-wrap gap-4 text-sm font-medium text-slate-600" aria-label="Social links">
            {% if site.social.linkedin %}<li><a class="hover:text-brand" href="{{ site.social.linkedin }}">LinkedIn</a></li>{% endif %}
            {% if site.social.dribbble %}<li><a class="hover:text-brand" href="{{ site.social.dribbble }}">Dribbble</a></li>{% endif %}
            {% if site.social.github %}<li><a class="hover:text-brand" href="{{ site.social.github }}">GitHub</a></li>{% endif %}
            {% if site.social.medium %}<li><a class="hover:text-brand" href="{{ site.social.medium }}">Medium</a></li>{% endif %}
          </ul>
          <p class="text-xs text-slate-400 sm:text-right">© {{ "now" | date: "%Y" }} {{ site.title }} · Built with Jekyll.</p>
        </div>
      </div>
    </footer>

    <script
      src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"
      integrity="sha384-hYHKH/s7frgVxH98p4J8C79yD6qxQFDoa+iMlO07mg51gUgJOMJ2K72I1H9EZGQw"
      crossorigin="anonymous"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/twgl.js@5.5.4/dist/twgl-full.min.js"></script>
    <script src="{{ '/assets/js/liquid-glass-gsap.js' | relative_url }}"></script>
    <script src="{{ '/assets/js/liquid-glass-nav.js' | relative_url }}"></script>
    <script>
      const baseBackgroundHex = '{{ site.data.background.color | default: "#030712" }}';

      const hexToRgb = (hex) => {
        if (typeof hex !== 'string') {
          return null;
        }

        const trimmed = hex.trim().replace('#', '');
        if (![3, 6].includes(trimmed.length)) {
          return null;
        }

        const normalized = trimmed.length === 3 ? trimmed.split('').map((char) => char + char).join('') : trimmed;
        const bigint = Number.parseInt(normalized, 16);

        if (Number.isNaN(bigint)) {
          return null;
        }

        return {
          r: (bigint >> 16) & 255,
          g: (bigint >> 8) & 255,
          b: bigint & 255
        };
      };

      const rgbToString = (color) => {
        if (!color) {
          return '';
        }
        return `rgb(${color.r}, ${color.g}, ${color.b})`;
      };

      const clamp01 = (value) => {
        const numeric = Number(value);
        if (Number.isNaN(numeric)) {
          return 0;
        }
        return Math.min(Math.max(numeric, 0), 1);
      };

      const mixRgb = (start, end, factor = 0.5) => {
        if (!start || !end) {
          return start || end || null;
        }

        const mixFactor = clamp01(factor);
        return {
          r: Math.round(start.r + (end.r - start.r) * mixFactor),
          g: Math.round(start.g + (end.g - start.g) * mixFactor),
          b: Math.round(start.b + (end.b - start.b) * mixFactor)
        };
      };

      const WHITE = { r: 255, g: 255, b: 255 };
      const BLACK = { r: 0, g: 0, b: 0 };

      const srgbChannelToLinear = (value) => {
        const channel = value / 255;
        if (channel <= 0.04045) {
          return channel / 12.92;
        }
        return Math.pow((channel + 0.055) / 1.055, 2.4);
      };

      const getRelativeLuminance = (color) => {
        if (!color) {
          return 0;
        }
        return 0.2126 * srgbChannelToLinear(color.r) + 0.7152 * srgbChannelToLinear(color.g) + 0.0722 * srgbChannelToLinear(color.b);
      };

      const mixWith = (color, target, factor) => mixRgb(color, target, factor);
      const lighten = (color, factor = 0.5) => mixWith(color, WHITE, factor);
      const darken = (color, factor = 0.5) => mixWith(color, BLACK, factor);

      const rgbaToString = (color, alpha = 1) => {
        if (!color) {
          return '';
        }
        return `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
      };

      const applyDynamicPalette = (baseColor) => {
        if (!baseColor) {
          return;
        }

        const luminance = getRelativeLuminance(baseColor);
        const isDarkBackground = luminance < 0.55;

        const glassBackgroundTint = isDarkBackground ? lighten(baseColor, 0.92) : darken(baseColor, 0.82);
        const glassBorderTint = isDarkBackground ? lighten(baseColor, 0.78) : darken(baseColor, 0.72);
        const glassTextTint = isDarkBackground ? darken(baseColor, 0.88) : lighten(baseColor, 0.94);
        const glassTextMutedTint = isDarkBackground ? darken(baseColor, 0.72) : lighten(baseColor, 0.8);
        const controlSurfaceTint = isDarkBackground ? lighten(baseColor, 0.88) : darken(baseColor, 0.78);
        const controlSurfaceHoverTint = isDarkBackground ? lighten(baseColor, 0.94) : darken(baseColor, 0.84);
        const controlTextTint = isDarkBackground ? darken(baseColor, 0.9) : lighten(baseColor, 0.96);

        const palette = isDarkBackground
          ? {
              '--dynamic-text-on-background': '#f8fafc',
              '--dynamic-text-muted': 'rgba(248, 250, 252, 0.72)',
              '--dynamic-glass-background': rgbaToString(glassBackgroundTint, 0.76),
              '--dynamic-glass-border': rgbaToString(glassBorderTint, 0.45),
              '--dynamic-glass-text': rgbToString(glassTextTint),
              '--dynamic-glass-text-muted': rgbaToString(glassTextMutedTint, 0.78),
              '--dynamic-control-surface': rgbaToString(controlSurfaceTint, 0.2),
              '--dynamic-control-surface-hover': rgbaToString(controlSurfaceHoverTint, 0.32),
              '--dynamic-control-text': rgbToString(controlTextTint)
            }
          : {
              '--dynamic-text-on-background': '#0f172a',
              '--dynamic-text-muted': 'rgba(15, 23, 42, 0.68)',
              '--dynamic-glass-background': rgbaToString(glassBackgroundTint, 0.6),
              '--dynamic-glass-border': rgbaToString(glassBorderTint, 0.38),
              '--dynamic-glass-text': rgbToString(glassTextTint),
              '--dynamic-glass-text-muted': rgbaToString(glassTextMutedTint, 0.74),
              '--dynamic-control-surface': rgbaToString(controlSurfaceTint, 0.18),
              '--dynamic-control-surface-hover': rgbaToString(controlSurfaceHoverTint, 0.28),
              '--dynamic-control-text': rgbToString(controlTextTint)
            };
=======
      const rgbaToString = ({ r, g, b }, alpha = 1) => `rgba(${r}, ${g}, ${b}, ${alpha})`;
      const rgbValuesToString = ({ r, g, b }) => `${r}, ${g}, ${b}`;

      const rgbToHsl = ({ r, g, b }) => {
        const rNorm = r / 255;
        const gNorm = g / 255;
        const bNorm = b / 255;
        const max = Math.max(rNorm, gNorm, bNorm);
        const min = Math.min(rNorm, gNorm, bNorm);
        const delta = max - min;
        let h = 0;
        let s = 0;
        const l = (max + min) / 2;

        if (delta !== 0) {
          s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);

          switch (max) {
            case rNorm:
              h = (gNorm - bNorm) / delta + (gNorm < bNorm ? 6 : 0);
              break;
            case gNorm:
              h = (bNorm - rNorm) / delta + 2;
              break;
            default:
              h = (rNorm - gNorm) / delta + 4;
              break;
          }

          h /= 6;
        }

        return { h, s, l };
      };

      const hslToRgb = ({ h, s, l }) => {
        const hueToRgb = (p, q, t) => {
          let tempT = t;
          if (tempT < 0) tempT += 1;
          if (tempT > 1) tempT -= 1;
          if (tempT < 1 / 6) return p + (q - p) * 6 * tempT;
          if (tempT < 1 / 2) return q;
          if (tempT < 2 / 3) return p + (q - p) * (2 / 3 - tempT) * 6;
          return p;
        };

        if (s === 0) {
          const gray = Math.round(l * 255);
          return { r: gray, g: gray, b: gray };
        }

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        const r = Math.round(hueToRgb(p, q, h + 1 / 3) * 255);
        const g = Math.round(hueToRgb(p, q, h) * 255);
        const b = Math.round(hueToRgb(p, q, h - 1 / 3) * 255);

        return { r, g, b };
      };

      const createAccentPalette = (color, isDarkBackground) => {
        const { h, s, l } = rgbToHsl(color);
        const boostedSaturation = clamp01(s * 1.35 + 0.08);
        const baseLightness = isDarkBackground
          ? Math.min(0.72, Math.max(l + 0.18, 0.55))
          : Math.max(0.3, Math.min(l - 0.2, 0.44));

        const base = hslToRgb({ h, s: boostedSaturation, l: baseLightness });
        const hover = hslToRgb({
          h,
          s: clamp01(boostedSaturation * (isDarkBackground ? 1.05 : 0.95)),
          l: isDarkBackground ? Math.min(0.82, baseLightness + 0.08) : Math.max(0.22, baseLightness - 0.08)
        });
        const strong = hslToRgb({
          h,
          s: clamp01(boostedSaturation * (isDarkBackground ? 1.02 : 1.1)),
          l: isDarkBackground ? Math.min(0.65, baseLightness + 0.02) : Math.max(0.18, baseLightness - 0.12)
        });
        const muted = hslToRgb({
          h,
          s: clamp01(boostedSaturation * 0.6),
          l: isDarkBackground ? Math.min(0.9, baseLightness + 0.18) : Math.max(0.16, baseLightness - 0.18)
        });

        const contrast = getRelativeLuminance(base) > 0.55 ? '#0f172a' : '#f8fafc';

        return { base, hover, strong, muted, contrast };
      };

      const applyDynamicPalette = (topColor, bottomColor) => {
        const midpoint = mixRgb(topColor, bottomColor, 0.5);
        const luminance = getRelativeLuminance(midpoint);
        const isDarkBackground = luminance < 0.48;

        const glassBackgroundTint = isDarkBackground ? darken(midpoint, 0.72) : lighten(midpoint, 0.82);
        const glassBorderTint = isDarkBackground ? darken(midpoint, 0.62) : lighten(midpoint, 0.7);
        const glassTextTint = isDarkBackground ? lighten(midpoint, 0.96) : darken(midpoint, 0.92);
        const glassTextMutedTint = isDarkBackground ? lighten(midpoint, 0.88) : darken(midpoint, 0.8);
        const controlSurfaceTint = isDarkBackground ? darken(midpoint, 0.64) : lighten(midpoint, 0.78);
        const controlSurfaceHoverTint = isDarkBackground ? darken(midpoint, 0.58) : lighten(midpoint, 0.86);
        const controlTextTint = isDarkBackground ? lighten(midpoint, 0.98) : darken(midpoint, 0.94);
        const textPrimaryTint = isDarkBackground ? lighten(midpoint, 0.98) : darken(midpoint, 0.92);
        const textMutedTint = isDarkBackground ? lighten(midpoint, 0.9) : darken(midpoint, 0.82);

        const glassBackgroundAlpha = isDarkBackground ? 0.78 : 0.62;
        const controlSurfaceAlpha = isDarkBackground ? 0.42 : 0.26;
        const controlSurfaceHoverAlpha = isDarkBackground ? 0.48 : 0.34;

        const navPanelTint = isDarkBackground ? darken(midpoint, 0.68) : lighten(midpoint, 0.86);
        const navPanelAlpha = isDarkBackground ? 0.88 : 0.72;
        const navBorderTint = isDarkBackground ? darken(midpoint, 0.58) : lighten(midpoint, 0.7);
        const navDividerTint = isDarkBackground ? lighten(midpoint, 0.78) : darken(midpoint, 0.62);
        const navOverlayTint = isDarkBackground ? darken(midpoint, 0.94) : darken(midpoint, 0.7);
        const navOverlayAlpha = isDarkBackground ? 0.68 : 0.5;
        const shadowTint = darken(midpoint, isDarkBackground ? 0.9 : 0.75);

        const palette = {
          '--dynamic-text-on-background': rgbToString(textPrimaryTint),
          '--dynamic-text-muted': rgbaToString(textMutedTint, isDarkBackground ? 0.82 : 0.78),
          '--dynamic-glass-background': rgbaToString(glassBackgroundTint, glassBackgroundAlpha),
          '--dynamic-glass-border': rgbaToString(glassBorderTint, isDarkBackground ? 0.5 : 0.42),
          '--dynamic-glass-text': rgbToString(glassTextTint),
          '--dynamic-glass-text-muted': rgbaToString(glassTextMutedTint, isDarkBackground ? 0.8 : 0.76),
          '--dynamic-control-surface': rgbaToString(controlSurfaceTint, controlSurfaceAlpha),
          '--dynamic-control-surface-hover': rgbaToString(controlSurfaceHoverTint, controlSurfaceHoverAlpha),
          '--dynamic-control-text': rgbToString(controlTextTint),
          '--dynamic-nav-panel-background': rgbaToString(navPanelTint, navPanelAlpha),
          '--dynamic-nav-panel-border': rgbaToString(navBorderTint, isDarkBackground ? 0.55 : 0.4),
          '--dynamic-nav-divider-rgb': rgbValuesToString(navDividerTint),
          '--dynamic-nav-overlay': rgbaToString(navOverlayTint, navOverlayAlpha),
          '--dynamic-shadow-rgb': rgbValuesToString(shadowTint)
        };

        const rootElement = document.documentElement;
        Object.entries(palette).forEach(([variable, value]) => {
          if (value) {
            rootElement.style.setProperty(variable, value);
          }
        });

        const { base, hover, strong, muted, contrast } = createAccentPalette(midpoint, isDarkBackground);
        const accentVariables = {
          '--dynamic-accent': rgbToString(base),
          '--dynamic-accent-rgb': rgbValuesToString(base),
          '--dynamic-accent-hover': rgbToString(hover),
          '--dynamic-accent-hover-rgb': rgbValuesToString(hover),
          '--dynamic-accent-strong': rgbToString(strong),
          '--dynamic-accent-strong-rgb': rgbValuesToString(strong),
          '--dynamic-accent-muted': rgbToString(muted),
          '--dynamic-accent-muted-rgb': rgbValuesToString(muted),
          '--dynamic-accent-contrast': contrast
        };

        Object.entries(accentVariables).forEach(([variable, value]) => {
          rootElement.style.setProperty(variable, value);
        });
      };

      const applyBackground = () => {
        const baseColor = hexToRgb(baseBackgroundHex);
        if (!baseColor) {
          return;
        }

        const rootElement = document.documentElement;
        const rgbString = `${baseColor.r}, ${baseColor.g}, ${baseColor.b}`;

        rootElement.style.setProperty('--sky-background-color', baseBackgroundHex);
        rootElement.style.setProperty('--sky-background-rgb', rgbString);
        rootElement.style.backgroundColor = baseBackgroundHex;

        const themeColorMeta = document.querySelector('meta[name="theme-color"]');
        if (themeColorMeta) {
          themeColorMeta.setAttribute('content', baseBackgroundHex);
        }

        applyDynamicPalette(baseColor);
      };

      applyBackground();

      const header = document.querySelector('[data-site-header]');
      const nav = document.querySelector('[data-nav]');
      const navToggle = nav?.querySelector('[data-nav-toggle]');
      const navOverlay = nav?.querySelector('[data-nav-overlay]');
      const navLinks = nav?.querySelectorAll('.site-nav__link');
      const root = document.documentElement;
      const isDesktop = () => window.matchMedia('(min-width: 768px)').matches;

      const setMobileOpen = (state) => {
        if (!navToggle) return;
        nav?.setAttribute('data-mobile-open', state.toString());
        navToggle.setAttribute('aria-expanded', state.toString());
        root.classList.toggle('has-mobile-nav', state);
      };

      const setNavCollapsed = (state) => {
        const shouldForceExpanded = isDesktop();
        const finalState = shouldForceExpanded ? false : state;
        nav?.setAttribute('data-collapsed', finalState.toString());
        header?.setAttribute('data-collapsed', finalState.toString());
        if (finalState) {
          setMobileOpen(false);
        }
      };

      let lastScrollY = window.scrollY;
      let scrollTicking = false;

      const handleScroll = () => {
        const currentY = window.scrollY;
        if (!isDesktop()) {
          setNavCollapsed(true);
          lastScrollY = currentY;
          return;
        }

        setNavCollapsed(false);

        lastScrollY = currentY;
      };

      window.addEventListener('scroll', () => {
        if (!scrollTicking) {
          window.requestAnimationFrame(() => {
            handleScroll();
            scrollTicking = false;
          });
          scrollTicking = true;
        }
      });

      const handleResize = () => {
        if (isDesktop()) {
          setNavCollapsed(false);
        } else {
          setNavCollapsed(true);
        }
        setMobileOpen(false);
      };

      window.addEventListener('resize', handleResize);
      handleResize();

      navToggle?.addEventListener('click', () => {
        if (isDesktop()) {
          setNavCollapsed(false);
          return;
        }
        const expanded = nav?.getAttribute('data-mobile-open') === 'true';
        setMobileOpen(!expanded);
      });

      navOverlay?.addEventListener('click', () => {
        setMobileOpen(false);
      });

      navLinks?.forEach((link) => {
        link.addEventListener('click', () => {
          if (!window.matchMedia('(min-width: 768px)').matches) {
            setMobileOpen(false);
          }
        });
      });

      window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && nav?.getAttribute('data-mobile-open') === 'true') {
          setMobileOpen(false);
        }
      });
    </script>
  </body>
</html>
