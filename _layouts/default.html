<!DOCTYPE html>
<html lang="en">
  <head>
    {% include head.html %}
  </head>
  <body class="flex min-h-screen flex-col font-sans">
    <a
      class="sr-only focus:not-sr-only focus:absolute focus:left-6 focus:top-6 focus:rounded-full focus:bg-[var(--two-tone-foreground)] focus:px-4 focus:py-2 focus:text-[var(--two-tone-background)]"
      href="#main"
      >Skip to content</a
    >
    <header class="site-header" data-site-header>
      <div class="site-header__bar">
        <a class="site-header__brand" href="{{ "/" | relative_url }}">{{ site.title }}</a>
        <nav class="site-nav" aria-label="Primary" data-nav>
          <button
            class="site-nav__toggle"
            aria-expanded="false"
            aria-controls="primary-navigation"
            type="button"
            data-nav-toggle
          >
            <span class="sr-only">Toggle navigation</span>
            <span aria-hidden="true" class="site-nav__toggle-bar"></span>
            <span aria-hidden="true" class="site-nav__toggle-bar"></span>
            <span aria-hidden="true" class="site-nav__toggle-bar site-nav__toggle-bar--short"></span>
          </button>
          <div class="site-nav__overlay" data-nav-overlay></div>
          <ul id="primary-navigation" class="site-nav__list" data-nav-list>
            {% for link in site.nav_links %}
            <li class="site-nav__item">
              <a class="site-nav__link" href="{{ link.url | relative_url }}">{{ link.title }}</a>
            </li>
            {% endfor %}
          </ul>
        </nav>
      </div>
    </header>

    <main id="main" class="flex-1 pt-28 md:pt-32">
      {{ content }}
    </main>

    <footer class="site-footer py-12">
      <div class="mx-auto flex w-full max-w-6xl flex-col gap-8 px-6 text-sm text-dynamic-muted sm:text-base lg:flex-row lg:items-start lg:justify-between">
        <div class="space-y-3">
          <p class="text-lg font-semibold text-dynamic">Let’s collaborate.</p>
          <a class="inline-flex items-center gap-2" href="mailto:{{ site.social.email }}">
            <span>{{ site.social.email }}</span>
          </a>
        </div>
        <div class="flex flex-1 flex-col gap-4 sm:flex-row sm:items-end sm:justify-end">
          <ul class="flex flex-wrap gap-4 text-sm font-medium text-dynamic-muted" aria-label="Social links">
            {% if site.social.linkedin %}<li><a href="{{ site.social.linkedin }}">LinkedIn</a></li>{% endif %}
            {% if site.social.dribbble %}<li><a href="{{ site.social.dribbble }}">Dribbble</a></li>{% endif %}
            {% if site.social.github %}<li><a href="{{ site.social.github }}">GitHub</a></li>{% endif %}
            {% if site.social.medium %}<li><a href="{{ site.social.medium }}">Medium</a></li>{% endif %}
          </ul>
          <p class="text-xs text-dynamic-muted sm:text-right">© {{ "now" | date: "%Y" }} {{ site.title }} · Built with Jekyll.</p>
        </div>
      </div>
    </footer>

    <script>
      const backgroundData = {{ site.data.background | jsonify | replace: '</', '<\/' }};
      const SKY_RUNTIME = (window.__skyRuntime = window.__skyRuntime || {});
      SKY_RUNTIME.backgroundData = backgroundData;
      const TOTAL_DAY_MINUTES = 24 * 60;

      const FALLBACK_BACKGROUND_HEX = (() => {
        if (backgroundData && typeof backgroundData.color === 'string' && backgroundData.color.trim()) {
          return backgroundData.color;
        }
        return '#050712';
      })();

      const hexToRgb = (hex) => {
        if (typeof hex !== 'string') {
          return null;
        }

        const trimmed = hex.trim().replace('#', '');
        if (![3, 6].includes(trimmed.length)) {
          return null;
        }

        const normalized = trimmed.length === 3 ? trimmed.split('').map((char) => char + char).join('') : trimmed;
        const bigint = Number.parseInt(normalized, 16);

        if (Number.isNaN(bigint)) {
          return null;
        }

        return {
          r: (bigint >> 16) & 255,
          g: (bigint >> 8) & 255,
          b: bigint & 255
        };
      };

      const rgbToString = (color) => {
        if (!color) {
          return '';
        }
        return `rgb(${color.r}, ${color.g}, ${color.b})`;
      };

      const clampCycleMinutes = (value) => {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) {
          return null;
        }
        const wrapped = ((numeric % TOTAL_DAY_MINUTES) + TOTAL_DAY_MINUTES) % TOTAL_DAY_MINUTES;
        return wrapped;
      };

      const clamp01 = (value) => {
        const numeric = Number(value);
        if (Number.isNaN(numeric)) {
          return 0;
        }
        return Math.min(Math.max(numeric, 0), 1);
      };

      const mixRgb = (start, end, factor = 0.5) => {
        if (!start || !end) {
          return start || end || null;
        }

        const mixFactor = clamp01(factor);
        return {
          r: Math.round(start.r + (end.r - start.r) * mixFactor),
          g: Math.round(start.g + (end.g - start.g) * mixFactor),
          b: Math.round(start.b + (end.b - start.b) * mixFactor)
        };
      };

      const WHITE = { r: 255, g: 255, b: 255 };
      const BLACK = { r: 0, g: 0, b: 0 };
      const BASE_DARK = { r: 15, g: 23, b: 42 };
      const BASE_LIGHT = { r: 248, g: 250, b: 252 };

      const srgbChannelToLinear = (value) => {
        const channel = value / 255;
        if (channel <= 0.04045) {
          return channel / 12.92;
        }
        return Math.pow((channel + 0.055) / 1.055, 2.4);
      };

      const getRelativeLuminance = (color) => {
        if (!color) {
          return 0;
        }
        return 0.2126 * srgbChannelToLinear(color.r) + 0.7152 * srgbChannelToLinear(color.g) + 0.0722 * srgbChannelToLinear(color.b);
      };

      const getContrastRatio = (colorA, colorB) => {
        if (!colorA || !colorB) {
          return 1;
        }
        const luminanceA = getRelativeLuminance(colorA);
        const luminanceB = getRelativeLuminance(colorB);
        const lighter = Math.max(luminanceA, luminanceB);
        const darker = Math.min(luminanceA, luminanceB);
        return (lighter + 0.05) / (darker + 0.05);
      };

      const mixWith = (color, target, factor) => mixRgb(color, target, factor);
      const lighten = (color, factor = 0.5) => mixWith(color, WHITE, factor);
      const darken = (color, factor = 0.5) => mixWith(color, BLACK, factor);

      const getMostContrastingColor = (background) => {
        if (!background) {
          return WHITE;
        }

        const baseCandidates = [WHITE, BLACK, BASE_LIGHT, BASE_DARK];
        const backgroundHsl = rgbToHsl(background);
        const complementaryHue = (backgroundHsl.h + 0.5) % 1;
        const complement = hslToRgb({ h: complementaryHue, s: Math.max(0.4, backgroundHsl.s * 1.1), l: 0.5 });

        baseCandidates.push(
          lighten(background, 0.95),
          lighten(background, 0.75),
          darken(background, 0.95),
          darken(background, 0.75),
          complement,
          lighten(complement, 0.45),
          darken(complement, 0.45)
        );

        let best = baseCandidates[0] || WHITE;
        let bestRatio = getContrastRatio(best, background);
        const seen = new Set();

        const pushCandidate = (candidate) => {
          if (!candidate) {
            return;
          }
          const key = `${candidate.r}-${candidate.g}-${candidate.b}`;
          if (seen.has(key)) {
            return;
          }
          seen.add(key);
          const ratio = getContrastRatio(candidate, background);
          if (ratio > bestRatio) {
            best = candidate;
            bestRatio = ratio;
          }
        };

        baseCandidates.forEach(pushCandidate);

        [0.35, 0.5, 0.65, 0.8].forEach((factor) => {
          pushCandidate(lighten(background, factor));
          pushCandidate(darken(background, factor));
        });

        return best;
      };

      const ensureComplementContrast = (tone, background, hue) => {
        if (!tone || !background) {
          return tone || null;
        }

        const desiredContrast = 4.5;
        const backgroundLuminance = getRelativeLuminance(background);
        let workingTone = tone;
        let workingHsl = rgbToHsl(workingTone);
        workingHsl.h = hue;

        let iterations = 0;
        const direction = backgroundLuminance > 0.5 ? -1 : 1;

        while (getContrastRatio(workingTone, background) < desiredContrast && iterations < 10) {
          workingHsl.l = clamp01(workingHsl.l + direction * 0.07);
          workingTone = hslToRgb(workingHsl);
          iterations += 1;
        }

        if (getContrastRatio(workingTone, background) >= desiredContrast) {
          return workingTone;
        }

        workingHsl = rgbToHsl(workingTone);
        iterations = 0;

        while (getContrastRatio(workingTone, background) < desiredContrast && iterations < 6) {
          workingHsl.s = clamp01(workingHsl.s + 0.08);
          workingTone = hslToRgb(workingHsl);
          iterations += 1;
        }

        return workingTone;
      };

      const getComplementaryTone = (background) => {
        if (!background) {
          return WHITE;
        }

        const backgroundHsl = rgbToHsl(background);
        const complementaryHue = (backgroundHsl.h + 0.5) % 1;
        const complementHsl = {
          h: complementaryHue,
          s: clamp01(Math.max(0.5, backgroundHsl.s * 1.1)),
          l: 0.52
        };

        let tone = hslToRgb(complementHsl);
        tone = ensureComplementContrast(tone, background, complementaryHue) || tone;

        if (getContrastRatio(tone, background) < 4.5) {
          const fallback = getMostContrastingColor(background);
          tone = mixRgb(tone, fallback, 0.35) || fallback;
        }

        return tone;
      };

      const getReadableTextOn = (background) => {
        return getMostContrastingColor(background);
      };

      const rgbaToString = (color, alpha = 1) => {
        if (!color) {
          return '';
        }
        const { r, g, b } = color;
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      };

      const rgbValuesToString = (color) => {
        if (!color) {
          return '0, 0, 0';
        }
        const { r, g, b } = color;
        return `${r}, ${g}, ${b}`;
      };

      const componentToHex = (value) => {
        const clamped = Math.max(0, Math.min(255, Math.round(value)));
        return clamped.toString(16).padStart(2, '0');
      };

      const rgbToHex = (color) => {
        if (!color) {
          return '';
        }
        return `#${componentToHex(color.r)}${componentToHex(color.g)}${componentToHex(color.b)}`;
      };

      const normalizeHex = (hex) => {
        const color = hexToRgb(hex);
        return color ? rgbToHex(color) : null;
      };

      const buildBackgroundConfig = (entry, fallbackLabel) => {
        if (!entry || typeof entry !== 'object') {
          return null;
        }

        const color = typeof entry.color === 'string' && entry.color.trim() ? entry.color : null;
        const label =
          (typeof entry.label === 'string' && entry.label.trim()) ||
          (typeof fallbackLabel === 'string' && fallbackLabel.trim()) ||
          '';

        if (!color) {
          return null;
        }

        return { color, label };
      };

      const parseTimeToMinutes = (value) => {
        const TOTAL_MINUTES = 24 * 60;

        if (typeof value === 'number' && Number.isFinite(value)) {
          const clampedHours = Math.max(0, Math.min(24, value));
          return Math.round(clampedHours * 60);
        }

        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) {
            return null;
          }

          const match = trimmed.match(/^(\d{1,2})(?::(\d{1,2}))?$/);
          if (!match) {
            return null;
          }

          const hours = Number.parseInt(match[1], 10);
          const minutes = match[2] ? Number.parseInt(match[2], 10) : 0;

          if (Number.isNaN(hours) || Number.isNaN(minutes)) {
            return null;
          }

          if (hours === 24 && minutes === 0) {
            return 0;
          }

          if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
            return null;
          }

          return hours * 60 + minutes;
        }

        return null;
      };

      const mapTimeAnchors = () => {
        const anchors = new Map();
        const TOTAL_MINUTES = 24 * 60;

        const registerAnchor = (minutes, entry) => {
          if (!Number.isFinite(minutes)) {
            return;
          }

          const normalizedMinutes = ((minutes % TOTAL_MINUTES) + TOTAL_MINUTES) % TOTAL_MINUTES;
          const config = buildBackgroundConfig(entry, backgroundData?.label);
          if (!config) {
            return;
          }

        const colorHex = normalizeHex(config.color);

        if (!colorHex) {
          return;
        }

        anchors.set(normalizedMinutes, {
          minutes: normalizedMinutes,
          color: colorHex,
          label: config.label
        });
      };

        if (backgroundData && Array.isArray(backgroundData.time_points)) {
          backgroundData.time_points.forEach((point) => {
            if (!point || typeof point !== 'object') {
              return;
            }

            const minutes =
              parseTimeToMinutes(point.time) ??
              parseTimeToMinutes(typeof point.hour === 'number' ? point.hour : null);

            registerAnchor(minutes, point);
          });
        } else if (backgroundData && Array.isArray(backgroundData.time_ranges)) {
          backgroundData.time_ranges.forEach((range) => {
            if (!range || typeof range !== 'object') {
              return;
            }

            const startMinutes = parseTimeToMinutes(range.start_hour);
            registerAnchor(startMinutes, range);
          });
        }

        return Array.from(anchors.values()).sort((a, b) => a.minutes - b.minutes);
      };

      const getDefaultBackground = () => {
        const fallback = buildBackgroundConfig(backgroundData?.default || backgroundData, backgroundData?.label);
        if (fallback && fallback.color) {
          return fallback;
        }

        return { color: FALLBACK_BACKGROUND_HEX, label: backgroundData?.label || '' };
      };

      const resolveInterpolatedBackground = () => {
        const anchors = mapTimeAnchors();
        if (!anchors.length) {
          return null;
        }

        if (anchors.length === 1) {
          const single = anchors[0];
          const minutesOverride = clampCycleMinutes(SKY_RUNTIME.timeOverrideMinutes);
          return {
            color: single.color,
            label: single.label,
            minutes: Number.isFinite(minutesOverride) ? minutesOverride : single.minutes
          };
        }

        const TOTAL_MINUTES = 24 * 60;
        const hasOverride = Number.isFinite(SKY_RUNTIME.timeOverrideMinutes);
        const overrideMinutes = hasOverride
          ? ((SKY_RUNTIME.timeOverrideMinutes % TOTAL_MINUTES) + TOTAL_MINUTES) % TOTAL_MINUTES
          : null;
        const now = hasOverride ? null : new Date();
        const currentMinutes = hasOverride
          ? overrideMinutes
          : now.getHours() * 60 + now.getMinutes() + now.getSeconds() / 60;

        let previous = anchors[anchors.length - 1];
        let next = anchors[0];

        for (const anchor of anchors) {
          if (currentMinutes >= anchor.minutes) {
            previous = anchor;
          } else {
            next = anchor;
            break;
          }
        }

        if (previous.minutes === next.minutes) {
          return {
            color: previous.color,
            label: previous.label,
            minutes: previous.minutes
          };
        }

        let startMinutes = previous.minutes;
        let endMinutes = next.minutes;

        if (endMinutes <= startMinutes) {
          endMinutes += TOTAL_MINUTES;
        }

        let elapsed = currentMinutes - startMinutes;
        if (elapsed < 0) {
          elapsed += TOTAL_MINUTES;
        }

        const duration = endMinutes - startMinutes;
        const mixFactor = duration === 0 ? 0 : clamp01(elapsed / duration);

        const startColor = hexToRgb(previous.color) || fallbackColor;
        const endColor = hexToRgb(next.color) || startColor;

        const baseColor = mixRgb(startColor, endColor, mixFactor) || startColor;

        const label = mixFactor < 0.5 ? previous.label : next.label || previous.label;
        const normalizedMinutes = ((currentMinutes % TOTAL_MINUTES) + TOTAL_MINUTES) % TOTAL_MINUTES;

        return {
          color: rgbToHex(baseColor),
          label,
          minutes: normalizedMinutes
        };
      };

      const getActiveBackground = () => {
        const interpolated = resolveInterpolatedBackground();
        if (interpolated) {
          return interpolated;
        }

        return getDefaultBackground();
      };

      const fallbackHexNormalized = normalizeHex(FALLBACK_BACKGROUND_HEX) || '#050712';
      const fallbackColor = hexToRgb(fallbackHexNormalized) || { r: 5, g: 7, b: 18 };
      const BACKGROUND_UPDATE_INTERVAL = 60 * 1000;

      let backgroundTransitionsReady = false;
      const enableBackgroundTransitions = () => {
        if (backgroundTransitionsReady) {
          return;
        }

        const rootElement = document.documentElement;
        if (!rootElement) {
          return;
        }

        backgroundTransitionsReady = true;
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            rootElement.classList.add('sky-background-transition-ready');
          });
        });
      };

      const rgbToHsl = (color) => {
        if (!color) {
          return { h: 0, s: 0, l: 0 };
        }
        const { r, g, b } = color;
        const rNorm = r / 255;
        const gNorm = g / 255;
        const bNorm = b / 255;
        const max = Math.max(rNorm, gNorm, bNorm);
        const min = Math.min(rNorm, gNorm, bNorm);
        const delta = max - min;
        let h = 0;
        let s = 0;
        const l = (max + min) / 2;

        if (delta !== 0) {
          s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);

          switch (max) {
            case rNorm:
              h = (gNorm - bNorm) / delta + (gNorm < bNorm ? 6 : 0);
              break;
            case gNorm:
              h = (bNorm - rNorm) / delta + 2;
              break;
            default:
              h = (rNorm - gNorm) / delta + 4;
              break;
          }

          h /= 6;
        }

        return { h, s, l };
      };

      const hslToRgb = ({ h, s, l }) => {
        const hueToRgb = (p, q, t) => {
          let tempT = t;
          if (tempT < 0) tempT += 1;
          if (tempT > 1) tempT -= 1;
          if (tempT < 1 / 6) return p + (q - p) * 6 * tempT;
          if (tempT < 1 / 2) return q;
          if (tempT < 2 / 3) return p + (q - p) * (2 / 3 - tempT) * 6;
          return p;
        };

        if (s === 0) {
          const gray = Math.round(l * 255);
          return { r: gray, g: gray, b: gray };
        }

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        const r = Math.round(hueToRgb(p, q, h + 1 / 3) * 255);
        const g = Math.round(hueToRgb(p, q, h) * 255);
        const b = Math.round(hueToRgb(p, q, h - 1 / 3) * 255);

        return { r, g, b };
      };

      const applyDynamicPalette = (baseColor) => {
        if (!baseColor) {
          return;
        }

        const foreground = getComplementaryTone(baseColor);
        const baseHex = rgbToHex(baseColor);
        const rootElement = document.documentElement;

        if (!rootElement) {
          return;
        }

        const palette = {
          '--dynamic-text-on-background': rgbToString(foreground),
          '--dynamic-text-muted': rgbaToString(foreground, 0.72),
          '--two-tone-background': baseHex,
          '--two-tone-background-rgb': rgbValuesToString(baseColor),
          '--two-tone-foreground': rgbToString(foreground),
          '--two-tone-foreground-rgb': rgbValuesToString(foreground),
          '--two-tone-foreground-muted': rgbaToString(foreground, 0.72)
        };

        Object.entries(palette).forEach(([variable, value]) => {
          if (value) {
            rootElement.style.setProperty(variable, value);
          }
        });
      };

      const applyBackground = () => {
        const activeBackground = getActiveBackground();
        const colorHex = normalizeHex(activeBackground?.color) || fallbackHexNormalized;

        const baseColor = hexToRgb(colorHex) || fallbackColor;
        const baseHex = rgbToHex(baseColor) || colorHex || fallbackHexNormalized;

        const rootElement = document.documentElement;
        rootElement.style.setProperty('--sky-background-color', baseHex);
        rootElement.style.setProperty('--sky-background-rgb', rgbValuesToString(baseColor));
        rootElement.style.backgroundColor = baseHex;
        rootElement.style.backgroundImage = 'none';

        if (activeBackground?.label) {
          rootElement.setAttribute('data-sky-label', activeBackground.label);
        } else {
          rootElement.removeAttribute('data-sky-label');
        }

        const themeColorMeta = document.querySelector('meta[name="theme-color"]');
        if (themeColorMeta) {
          themeColorMeta.setAttribute('content', baseHex);
        }

        applyDynamicPalette(baseColor);
        enableBackgroundTransitions();

        const normalizedMinutes = Number.isFinite(SKY_RUNTIME.timeOverrideMinutes)
          ? clampCycleMinutes(SKY_RUNTIME.timeOverrideMinutes)
          : clampCycleMinutes(activeBackground?.minutes);
        const detail = {
          color: baseHex,
          base: baseHex,
          hex: baseHex,
          label: activeBackground?.label || '',
          minutes: normalizedMinutes,
          isOverride: Number.isFinite(SKY_RUNTIME.timeOverrideMinutes)
        };
        SKY_RUNTIME.lastAppliedBackground = detail;
        window.dispatchEvent(new CustomEvent('sky:background-applied', { detail }));
      };

      SKY_RUNTIME.applyBackground = () => {
        applyBackground();
      };
      SKY_RUNTIME.setTimeOverride = (minutes) => {
        const normalized = clampCycleMinutes(minutes);
        if (Number.isFinite(normalized)) {
          SKY_RUNTIME.timeOverrideMinutes = normalized;
        } else {
          delete SKY_RUNTIME.timeOverrideMinutes;
        }
        applyBackground();
      };
      SKY_RUNTIME.clearTimeOverride = () => {
        delete SKY_RUNTIME.timeOverrideMinutes;
        applyBackground();
      };

      applyBackground();
      window.setInterval(applyBackground, BACKGROUND_UPDATE_INTERVAL);

      const header = document.querySelector('[data-site-header]');
      const nav = document.querySelector('[data-nav]');
      const navToggle = nav?.querySelector('[data-nav-toggle]');
      const navOverlay = nav?.querySelector('[data-nav-overlay]');
      const navLinks = nav?.querySelectorAll('.site-nav__link');
      const root = document.documentElement;
      const isDesktop = () => window.matchMedia('(min-width: 768px)').matches;

      const setMobileOpen = (state) => {
        if (!navToggle) return;
        nav?.setAttribute('data-mobile-open', state.toString());
        navToggle.setAttribute('aria-expanded', state.toString());
        root.classList.toggle('has-mobile-nav', state);
      };

      const setNavCollapsed = (state) => {
        const shouldForceExpanded = isDesktop();
        const finalState = shouldForceExpanded ? false : state;
        nav?.setAttribute('data-collapsed', finalState.toString());
        header?.setAttribute('data-collapsed', finalState.toString());
        if (finalState) {
          setMobileOpen(false);
        }
      };

      let lastScrollY = window.scrollY;
      let scrollTicking = false;

      const handleScroll = () => {
        const currentY = window.scrollY;
        if (!isDesktop()) {
          setNavCollapsed(true);
          lastScrollY = currentY;
          return;
        }

        setNavCollapsed(false);

        lastScrollY = currentY;
      };

      window.addEventListener('scroll', () => {
        if (!scrollTicking) {
          window.requestAnimationFrame(() => {
            handleScroll();
            scrollTicking = false;
          });
          scrollTicking = true;
        }
      });

      const handleResize = () => {
        if (isDesktop()) {
          setNavCollapsed(false);
        } else {
          setNavCollapsed(true);
        }
        setMobileOpen(false);
      };

      window.addEventListener('resize', handleResize);
      handleResize();

      navToggle?.addEventListener('click', () => {
        if (isDesktop()) {
          setNavCollapsed(false);
          return;
        }
        const expanded = nav?.getAttribute('data-mobile-open') === 'true';
        setMobileOpen(!expanded);
      });

      navOverlay?.addEventListener('click', () => {
        setMobileOpen(false);
      });

      navLinks?.forEach((link) => {
        link.addEventListener('click', () => {
          if (!window.matchMedia('(min-width: 768px)').matches) {
            setMobileOpen(false);
          }
        });
      });

      window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && nav?.getAttribute('data-mobile-open') === 'true') {
          setMobileOpen(false);
        }
      });
    </script>
  </body>
</html>
